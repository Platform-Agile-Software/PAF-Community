//@#$&+
//
//The MIT X11 License
//
//Copyright (c) 2010 - 2017 Icucom Corporation
//
//Permission is hereby granted, free of charge, to any person obtaining a copy
//of this software and associated documentation files (the "Software"), to deal
//in the Software without restriction, including without limitation the rights
//to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//copies of the Software, and to permit persons to whom the Software is
//furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in
//all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//THE SOFTWARE.
//@#$&-

using System;
using PlatformAgileFramework.Collections;
using PlatformAgileFramework.ErrorAndException;
using PlatformAgileFramework.MultiProcessing.AsyncControl;
using PlatformAgileFramework.QualityAssurance.TestFrameworks.BasicxUnitEmulator.Display.Exceptions;
using PlatformAgileFramework.QualityAssurance.TestFrameworks.BasicxUnitEmulator.Exceptions;
using PlatformAgileFramework.TypeHandling.TypeExtensionMethods;

// Exception shorthand.
using PAED = PlatformAgileFramework.ErrorAndException.PAFAggregateExceptionData;

namespace PlatformAgileFramework.QualityAssurance.TestFrameworks.BasicxUnitEmulator
{
	/// <summary>
	/// This part of the class contains a simple test runner - just does the standard
	/// NUnit/JUnit thing.
	/// </summary>
	/// <history>
	/// <contribution>
	/// <author> JAW(P) </author>
	/// <date> 20dec2016 </date>
	/// <description>
	/// Left the standard NUnit runner in for PAFCommunity.
	/// </description>
	/// </contribution>
	/// </history>
	/// <threadsafety>
	/// Synchronized as well as implementations of the data interfaces we touch are. The
	/// standard PAF implementations of <see cref="IPAFTestFixtureInfo"/> and the like
	/// are synchronized.
	/// </threadsafety>
	// ReSharper disable PartialTypeWithSinglePart
	public partial class TestRunnerDelegateMethods
// ReSharper restore PartialTypeWithSinglePart
	{
		#region Methods
		/// <summary>
		/// <para>
		/// Iterates over methods on a test fixture, calling the setup method before
		/// and the teardown method after, if they exist. Returns <see cref="Exception"/>s
		/// that are appropriate for error conditions in any of the methods.
		/// </para>
		/// <para>
		/// Exceptions are returned to the caller that should invalidate
		/// the fixture and prevent any further calls on it. Any FIXTURE/TEST SETUP/TEARDOWN
		/// method failure invalidates the fixture. Exceptions generated by individual TEST
		/// methods do not. They are placed on the individual <see cref="IPAFTestMethodInfo"/>
		/// corresponding to the test methods, along with setting its status to the passed=false
		/// state. See next.....
		/// </para>
		/// <para>
		/// A TEST method may fail with exceptions.
		/// The exceptions that are placed on test method's <see cref="IPAFTestMethodInfo"/>
		/// are: 
		/// <see cref="PAFStandardException{PTFMED}"/>,  with data:
		/// <see cref="PAFTestFixtureMethodExceptionMessageTags.TEST_METHOD_FAILURE"/>.
		/// The test method's <see cref="IPAFTestMethodInfo"/> is not set to
		/// an invalid state, but exceptions are recorded in its collection. An exception will
		/// set its <see cref="IPAFTestElementInfo.Passed"/> to <see langword="false"/>. A successful execution
		/// will set it to <see langword="true"/>. Extended allows test methods to be re-run in the same test
		/// run. Thus, they can't be invalidated with a single failure.
		/// </para>
		/// <para>
		/// This test runner method will invalidate the fixture and quit on the first FIXTURE/TEST
		/// SETUP/TEARDOWN failure, so the wrapper does not need to do this. If any
		/// <see cref="IPAFTestMethodInfo"/> executed by this runner method throws an
		/// exception, the fixture info is set to have failed. This is consistent with ordinary
		/// NUnit philosophy. The exception is for <see cref="PAFTestFixtureMethodExceptionMessageTags.TEST_RUNNER_FAILURE"/>,
		/// which is designed to be handled by the wrapper.
		/// </para>
		/// </summary>
		/// <history>
		/// <author> BMC </author>
		/// <date> 23apr2012 </date>
		/// <contribution>
		/// Put the Quick Abort capability in after exposing the Abort signal in the
		/// async library.
		/// </contribution>
		/// </history>
		/// <history>
		/// <author> KRM </author>
		/// <date> 01apr2012 </date>
		/// <contribution>
		/// Reformulated to take provider arguments so that an <see cref="IAsyncControlObject"/>
		/// could be passed in directly to this method. This was necessary when moving to the
		/// Silverlight model, since we can't abort threads in this model. This allows us
		/// to stop processing in this test method loop, which may be very long-winded if
		/// arbitrary enumerators are allowed. Noted that the test method loop will stop
		/// after the current test completes, but the test tear down and test fixture tear
		/// down methods will still be run before this method exits. This behavior allows
		/// the tester to simply stop the operation of the current fixture and move on to
		/// the next, while keeping the test data in a valid state. Control with the
		/// <see cref="IAsyncControlObject"/> skips these final calls and also will
		/// interrupt immediately before/after any setup or fixture setup call and just quit.
		/// </contribution>
		/// </history>
		/// <param name="testFixtureWrapperProvider"><see cref="IPAFTestFixtureWrapper"/> for the test.</param>
		/// <returns>
		/// Signal exceptions indicating failures in setup, or teardown. The method
		/// may return an <see cref="PAFStandardException{PAED}"/>, an aggregate exception.
		/// The exceptions are all standard exceptions <see cref="PAFStandardException{PTFMED}"/>
		/// with following possible data:
		/// <exception> <see cref="PAFTestFixtureMethodExceptionMessageTags.FIXTURE_SETUP_FAILURE"/> </exception>
		/// <exception> <see cref="PAFTestFixtureMethodExceptionMessageTags.TEST_SETUP_FAILURE"/> </exception>
		/// <exception> <see cref="PAFTestFixtureMethodExceptionMessageTags.TEST_METHOD_FAILURE"/> </exception>
		/// <exception> <see cref="PAFTestFixtureMethodExceptionMessageTags.TEST_TEARDOWN_FAILURE"/> </exception>
		/// <exception> <see cref="PAFTestFixtureMethodExceptionMessageTags.FIXTURE_TEARDOWN_FAILURE"/> </exception>
		/// <exception>
		/// <see cref="PAFTestFixtureMethodExceptionMessageTags.TEST_RUNNER_FAILURE"/> is an exception returned that wraps
		/// any miscellaneous exceptions that may occur (bad params, etc.).
		/// </exception>
		/// </returns>
		// NOTE: KRM - this should have always used the enumerators on the wrapper.
		public static Exception SimpleTestRunner(
			IPAFTestFixtureWrapperProvider testFixtureWrapperProvider)
		{
			if (testFixtureWrapperProvider == null) throw new ArgumentNullException("testFixtureWrapperProvider");
			// Create the data item that will hold our exceptions, along with our standard exception.
			// Note that this is used to return exceptions to the caller that should invalidate
			// the fixture and prevent any further calls on it. Any fixture/test setup/teardown
			// invalidates the fixture. Exceptions generated by individual test methods do not.
			var pAed = new PAED();
			var aggregateException = new PAFStandardException<PAED>(pAed);
			var testFixtureWrapper = testFixtureWrapperProvider.ProvidedFixtureWrapper;
			// We set this optimstically.
			testFixtureWrapper.FixtureInfo.Passed = true;
			// Giant try/catch to protect us from anything.
			try
			{
				var testFixtureInfo = testFixtureWrapperProvider.ProvidedFixtureWrapper.FixtureInfo;
				if (testFixtureInfo == null) throw new ArgumentException("testFixtureInfo");
				if (testFixtureInfo.FixtureInstance == null) throw new Exception("No fixture instance", null);

				// See if we have a control object coming in.
				IAsyncControlObject asyncControlObject = null;
				if (testFixtureWrapperProvider is IAsyncControlObjectProvider asyncControlObjectProvider)
					asyncControlObject = asyncControlObjectProvider.ProvidedControlObject;

				// Initialize variables for our loop.
				testFixtureInfo.NumTimesAnyTestCalled = 0;
				testFixtureInfo.HasFixtureSetupBeenCalled = false;
				testFixtureInfo.HasFixtureTearDownBeenCalled = false;


				// Test framework method we are working on.
				IPAFTestMethodInfo testFMI = null;

				foreach (var testMethodInfo in testFixtureWrapper.GetTestElementInfoResettableEnumerableProviderProvider().EnumerableProvider.GetEnumerable())
				{
					// Quick Abort
					if (TestShouldAbort(asyncControlObject)) return aggregateException;
					///////////////////////////////////////////////////////////////
					// Fixture setup execution
					///////////////////////////////////////////////////////////////
					try
					{
						testFMI = testFixtureInfo.FixtureSetUpMethod;
						if ((testFMI != null) && (!testFixtureInfo.HasFixtureSetupBeenCalled))
							testFMI.FrameworkMethodInfo.Invoke(testFixtureInfo.FixtureInstance, null);
					}
					catch (Exception ex)
					{
						// ReSharper disable PossibleNullReferenceException
						var newEx =
							new PAFStandardException<IPAFTestFixtureInitializationExceptionData>(
								new PAFTestFixtureInitializationExceptionData(testFixtureInfo.FixtureType, testFMI.FrameworkMethodName),
								PAFTestFixtureMethodExceptionMessageTags.FIXTURE_SETUP_FAILURE, ex);
						// ReSharper restore PossibleNullReferenceException
						// Kill both fixture and method.
						testFMI.SetElementInfoErrors(true, newEx, false);
						testFixtureInfo.SetElementInfoErrors(true, newEx, false);
						pAed.AddException(newEx);
						testFixtureInfo.Passed = false;
						return aggregateException;
					}
					///////////////////////////////////////////////////////////////
					// Test setup execution
					///////////////////////////////////////////////////////////////
					// Quick Abort
					if (TestShouldAbort(asyncControlObject)) return aggregateException;
					try
					{
						testFMI = testFixtureInfo.TestSetUpMethod;
						testFMI?.FrameworkMethodInfo.Invoke(testFixtureInfo.FixtureInstance, null);
					}
					catch (Exception ex)
					{
						// ReSharper disable PossibleNullReferenceException
						var newEx =
							new PAFStandardException<IPAFTestFixtureInitializationExceptionData>(
								new PAFTestFixtureInitializationExceptionData(testFixtureInfo.FixtureType, testFMI.FrameworkMethodName),
								PAFTestFixtureMethodExceptionMessageTags.TEST_SETUP_FAILURE, ex);
						// ReSharper restore PossibleNullReferenceException
						// Kill both fixture and method.
						testFMI.SetElementInfoErrors(true, newEx, false);
						testFixtureInfo.SetElementInfoErrors(true, newEx, false);
						pAed.AddException(newEx);
						testFixtureInfo.Passed = false;
						return aggregateException;
					}
					///////////////////////////////////////////////////////////////
					// Actual test method execution
					///////////////////////////////////////////////////////////////
					// Quick Abort
					if (TestShouldAbort(asyncControlObject)) return aggregateException;
					try
					{
						testFMI = testMethodInfo;
						testFMI.FrameworkMethodInfo.Invoke(testFixtureInfo.FixtureInstance, null);
						testFMI.Passed = true;
					}
					catch (Exception ex)
					{
						var newEx =
							new PAFStandardException<IPAFTestFixtureInitializationExceptionData>(
								// ReSharper disable once PossibleNullReferenceException
								new PAFTestFixtureInitializationExceptionData(testFixtureInfo.FixtureType, testFMI.FrameworkMethodName),
								// ReSharper restore PossibleNullReferenceException
								PAFTestFixtureMethodExceptionMessageTags.TEST_METHOD_FAILURE, ex);
						// Set the method to have failed and attach the exception. Do not invalidate.
						testFMI.SetElementInfoErrors(false, newEx, false);
						// Set the method to have failed.
						testFMI.Passed = false;
						// Set the fixture to have failed.
						testFixtureInfo.Passed = false;
					}
					///////////////////////////////////////////////////////////////
					// Test teardown execution.
					///////////////////////////////////////////////////////////////
					// Quick Abort
					if (TestShouldAbort(asyncControlObject)) return aggregateException;
					try
					{
						testFMI = testFixtureInfo.TestTearDownMethod;
						testFMI?.FrameworkMethodInfo.Invoke(testFixtureInfo.FixtureInstance, null);
					}
					catch (Exception ex)
					{
						// ReSharper disable PossibleNullReferenceException
						var newEx =
							new PAFStandardException<IPAFTestFixtureInitializationExceptionData>(
								new PAFTestFixtureInitializationExceptionData(testFixtureInfo.FixtureType, testFMI.FrameworkMethodName),
								PAFTestFixtureMethodExceptionMessageTags.TEST_TEARDOWN_FAILURE, ex);
						// ReSharper restore PossibleNullReferenceException
						// Kill both fixture and method.
						testFMI.SetElementInfoErrors(true, newEx, false);
						testFixtureInfo.SetElementInfoErrors(true, newEx, false);
						pAed.AddException(newEx);
						testFixtureInfo.Passed = false;
						return aggregateException;
					}

					#region JUnit Behavior

					// Junit behavior is mostly a test on test setup problems. It forces a call
					// of the fixture setup every time.
					// Quick Abort
					if (TestShouldAbort(asyncControlObject)) return aggregateException;
					if (testFixtureInfo.FrameworkBehavior.FrameworkBehaviorType != TestFrameworkBehaviorType.JUnit)
						// If we are not emulating jUnit, shut off further calls to fixture setup.
						testFixtureInfo.HasFixtureSetupBeenCalled = true;
					else
					{
						try
						{
							testFMI = testFixtureInfo.FixtureTearDownMethod;
							testFMI?.FrameworkMethodInfo.Invoke(testFixtureInfo.FixtureInstance, null);
						}
						catch (Exception ex)
						{
							// ReSharper disable PossibleNullReferenceException
							var newEx =
								new PAFStandardException<IPAFTestFixtureInitializationExceptionData>(
									new PAFTestFixtureInitializationExceptionData(testFixtureInfo.FixtureType, testFMI.FrameworkMethodName),
									PAFTestFixtureMethodExceptionMessageTags.FIXTURE_TEARDOWN_FAILURE, ex);
							// ReSharper restore PossibleNullReferenceException
							// Kill both fixture and method.
							testFMI.SetElementInfoErrors(true, newEx, false);
							testFixtureInfo.SetElementInfoErrors(true, newEx, false);
							pAed.AddException(newEx);
							testFixtureInfo.Passed = false;
							return aggregateException;
						}
						// Don't want to call twice. Setup/Teardown must be exactly paired.
						testFixtureInfo.HasFixtureTearDownBeenCalled = true;
					}

					#endregion // JUnit Behavior

					testFixtureInfo.NumTimesAnyTestCalled++;
					// Our behavior is to stop on any exceptions.
					if (TestShouldStop(testFixtureInfo, asyncControlObject)
					    || (pAed.Exceptions.GetFirstElement() != null)) break;
				}

				#region Final Cleanup

				// Quick Abort
				if (TestShouldAbort(asyncControlObject)) return aggregateException;
				if (!testFixtureInfo.HasFixtureTearDownBeenCalled)
				{
					try
					{
						testFMI = testFixtureInfo.FixtureTearDownMethod;
						testFMI?.FrameworkMethodInfo.Invoke(testFixtureInfo.FixtureInstance, null);
					}
					catch (Exception ex)
					{
						// ReSharper disable PossibleNullReferenceException
						var newEx =
							new PAFStandardException<IPAFTestFixtureInitializationExceptionData>(
								new PAFTestFixtureInitializationExceptionData(testFixtureInfo.FixtureType, testFMI.FrameworkMethodName),
								PAFTestFixtureMethodExceptionMessageTags.FIXTURE_TEARDOWN_FAILURE, ex);
						// ReSharper restore PossibleNullReferenceException
						// Kill both fixture and method.
						testFMI.SetElementInfoErrors(true, newEx, false);
						testFixtureInfo.SetElementInfoErrors(true, newEx, false);
						pAed.AddException(newEx);
						testFixtureInfo.Passed = false;
						return aggregateException;
					}
				}

				#endregion // Final Cleanup
				if ((pAed.Exceptions.GetFirstElement() != null))
					return aggregateException;
				// All is well.
				return null;


			}
			catch (Exception ex)
			{
				// If we got here, something happened in the entry to the method or something
				// very wierd happened.
				var data = new PAFTestFixtureInitializationExceptionData(typeof(TestRunnerDelegateMethods).ToTypeholder(), "SimpleTestRunner");
				var newEx = new PAFStandardException<PAFTestFixtureInitializationExceptionData>(data, PAFTestFixtureMethodExceptionMessageTags.TEST_RUNNER_FAILURE,
					ex);
				return newEx;
			}
		}
		/// <summary>
		/// Just a tiny little helper to determine stopping criterion.
		/// </summary>
		/// <param name="asyncControlObject">
		/// Can be <see langword="null"/>.
		/// </param>
		/// <returns>
		/// <see langword="false"/> if <paramref name="asyncControlObject"/> is <see langword="null"/>.
		/// </returns>
		public static bool TestShouldAbort(IAsyncControlObject asyncControlObject)
		{
			var coInternal = asyncControlObject as IAsyncControlObjectInternal;
			if (coInternal?.IsAborting == true) return true;
			return false;
		}
		/// <summary>
		/// Just a tiny little helper to determine stopping criterion.
		/// </summary>
		/// <param name="testFixtureInfo">
		/// Cannot be <see langword="null"/>.
		/// </param>
		/// <param name="asyncControlObject">
		/// Can be <see langword="null"/>. In this case no stopping criteria from the control object
		/// is used.
		/// </param>
		/// <returns>
		/// Stopping criteria are checked in this order:
		/// <see langword="true"/> if <c>asyncControlObject.ProcessShouldTerminate</c>.
		/// <see langword="false"/> if <c>testFixtureInfo.MaxTimesAnyTestCalled</c> is -1.
		/// <see langword="true"/> if <c>testFixtureInfo.NumTimesAnyTestCalled</c> is greater or equal
		/// to <c>testFixtureInfo.MaxTimesAnyTestCalled</c>.
		/// </returns>
		/// <exceptions>
		/// <exception> <see cref="ArgumentNullException"/> is thrown:
		/// <c>"testFixtureInfo"</c> if the <paramref name="testFixtureInfo"/> is <see langword="null"/>.
		/// </exception>
		/// </exceptions>
		public static bool TestShouldStop(IPAFTestFixtureInfo testFixtureInfo,
			IAsyncControlObject asyncControlObject)
		{
			if (testFixtureInfo == null) throw new ArgumentNullException("testFixtureInfo");
			if (TestShouldAbort(asyncControlObject)) return true;
			if (testFixtureInfo.MaxTimesAnyTestCalled == -1) return false;
			return testFixtureInfo.NumTimesAnyTestCalled >= testFixtureInfo.MaxTimesAnyTestCalled;
		}
		#endregion // Methods
	}
}
