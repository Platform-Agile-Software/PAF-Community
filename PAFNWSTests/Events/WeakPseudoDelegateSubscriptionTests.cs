using System;using System.Threading;using NUnit.Framework;using PlatformAgileFramework.FrameworkServices.Tests;using PlatformAgileFramework.Notification.SubscriberStores;using PlatformAgileFramework.Notification.TestHelpers;using PlatformAgileFramework.TypeHandling.Delegates;// ReSharper disable once CheckNamespace

namespace PlatformAgileFramework.Events.Tests{
	/// <summary>	/// Tests for subscribing and unsubscribing <see cref="IPseudoDelegate{TDelegate}"/>s.	/// We test both static and instance delegates. 	/// </summary>    [TestFixture]	public class WeakPseudoDelegateSubscriptionTests : BasicServiceManagerTestFixtureBase	{		public static bool s_SubscriberFinalized;		public static int s_NumNotificationsBroadcast;		public static int s_SumOfIntegersReceived;		/// <summary>
		/// This is subscriber that weakly subscribes with an instance method,		/// thus can die.
		/// </summary>		public WeakIntegerDelegateTestClass m_InstanceSubscriber;
		/// <summary>
		/// This is a subscriber that weakly subscribes with a		/// static method, thus will never die, but can be unsubscribed. 
		/// </summary>
		public WeakIntegerDelegateTestClass m_StaticSubscriber;		public IWeakableSubscriberStore<Action<int>> m_PublisherHookedToInstance;		public IWeakableSubscriberStore<Action<int>> m_PublisherHookedToStatic;		/// <summary>		/// We create two publishers, each loaded with a different integer		/// and subscribe to them weakly. One subscription is static,		/// the other instance.		/// </summary>		[SetUp]		public override void SetUp()		{			base.SetUp();			// Kill publishers if alive.			DisposePublishers();			s_SubscriberFinalized = false;			s_NumNotificationsBroadcast = 0;			s_SumOfIntegersReceived = 0;			m_InstanceSubscriber = new WeakIntegerDelegateTestClass();			m_StaticSubscriber = new WeakIntegerDelegateTestClass(true);			m_PublisherHookedToInstance = new WeakableIntegerSubscriberStore(1);			m_PublisherHookedToStatic = new WeakableIntegerSubscriberStore(2);			m_InstanceSubscriber.WeaklySubscribe(m_PublisherHookedToInstance);			m_StaticSubscriber.WeaklySubscribe(m_PublisherHookedToStatic);		}		/// <summary>		/// This one tests the death of the instance, but not the static.		/// </summary>		[Test]		public void LetInstanceButNotStaticSubscriptionDie()		{			m_PublisherHookedToInstance.NotifySubscribers();			m_PublisherHookedToStatic.NotifySubscribers();			Assert.IsTrue(s_NumNotificationsBroadcast == 2, "Both Static and Instance");			// The instance subscriber weak reference should now be able to die.			m_InstanceSubscriber = null;			// But the static subscriber should not.			m_StaticSubscriber = null;			GC.Collect();			GC.WaitForPendingFinalizers();			GC.Collect();			// See if the reference was really released.			Assert.IsTrue(s_SubscriberFinalized);			m_PublisherHookedToInstance.NotifySubscribers();			m_PublisherHookedToStatic.NotifySubscribers();			// Now the static subscriber should have incremented			// the count by one.			Assert.IsTrue(s_NumNotificationsBroadcast == 3, "Static yes, Instance no");		}		/// <summary>		/// This checks that we can unsubscribe the static and the instance subscriptions.		/// </summary>		[Test]		public void CheckSuccessfulUnsubscriptionOfInstanceAndStatic()		{			m_PublisherHookedToInstance.NotifySubscribers();			m_PublisherHookedToStatic.NotifySubscribers();			Assert.IsTrue(s_NumNotificationsBroadcast == 2, "Both Static and Instance are subscribed");			m_InstanceSubscriber.UnSubscribe(m_PublisherHookedToInstance);			m_StaticSubscriber.UnSubscribe(m_PublisherHookedToStatic);			m_PublisherHookedToInstance.NotifySubscribers();			m_PublisherHookedToStatic.NotifySubscribers();			// Now the count should remain the same.			Assert.IsTrue(s_NumNotificationsBroadcast == 2, "Both Static and Instance are unsubscribed");		}
		/// <summary>
		/// Just kills the publishers without killing the Service base.
		/// </summary>        public void DisposePublishers()		{			m_PublisherHookedToInstance?.Dispose();			m_PublisherHookedToStatic?.Dispose();		}		public override void Dispose()		{			DisposePublishers();			base.Dispose();		}	}	/// <summary>
	/// Little test class that allows us to control whether we	/// hook up to our static method or our instance method.	/// This is intended to test subscription/unsubscription	/// of both instance and static methods.
	/// </summary>	public class WeakIntegerDelegateTestClass	{		private readonly bool m_StaticMethodSubscription;		/// <summary>
		/// Constructor lets us control instance/static.
		/// </summary>
		/// <param name="staticMethodSubscription">		/// <see langword = "True"/> for hooking up the static method.		/// default = <see langword = "false"/>.		/// </param>		public WeakIntegerDelegateTestClass(bool staticMethodSubscription = false)		{			m_StaticMethodSubscription = staticMethodSubscription;		}		private static void LogEventOccurance()		{			// We have to use an interlocked method, since this poor			// test class might get invoked on multiple threads.			Interlocked.Add(ref WeakPseudoDelegateSubscriptionTests.s_NumNotificationsBroadcast, 1);		}		/// <summary>		/// Subscribes our static/instance method, depending		/// on construction option.		/// </summary>		/// <param name="publisher">Notification publisher.</param>		public void WeaklySubscribe(IWeakableSubscriberStore<Action<int>> publisher)		{			if(m_StaticMethodSubscription == false)				publisher.WeaklySubscribe(Execute);			else				publisher.WeaklySubscribe(ExecuteStatic);		}		/// <summary>		/// Subscribes our static/instance method, depending		/// on construction option.		/// </summary>		/// <param name="publisher">Notification publisher.</param>		public void StronglySubscribe(IWeakableSubscriberStore<Action<int>> publisher)		{			if (m_StaticMethodSubscription == false)				publisher.Subscribe(Execute, false);			else				publisher.Subscribe(ExecuteStatic, false);		}		/// <summary>		/// Unsubscribes our static/instance method, depending		/// on construction option.		/// </summary>		/// <param name="publisher">Notification publisher.</param>		public void UnSubscribe(IWeakableSubscriberStore<Action<int>> publisher)		{			if (m_StaticMethodSubscription == false)				publisher.Unsubscribe(Execute);			else				publisher.Unsubscribe(ExecuteStatic);		}
		/// <summary>
		/// Instance method - same old thing, but with a twist! Just		/// calls the static.
		/// </summary>
		/// <param name="integerPayload">Payload.</param>        public void Execute(int integerPayload)		{			ExecuteStatic(integerPayload);		}		/// <summary>		/// Static method to test unsubscribe on.		/// </summary>		/// <param name="integerPayload">Payload.</param>		public static void ExecuteStatic(int integerPayload)		{			WeakPseudoDelegateSubscriptionTests.s_SumOfIntegersReceived += integerPayload;			LogEventOccurance();		}		~WeakIntegerDelegateTestClass()		{			WeakPseudoDelegateSubscriptionTests.s_SubscriberFinalized = true;		}	}}