using System.ComponentModel;using NUnit.Framework;using PlatformAgileFramework.Events.EventTestHelpers;using PlatformAgileFramework.FrameworkServices.Tests;namespace PlatformAgileFramework.Events{
	/// <summary>	/// Tests for the standard <see cref="INotifyPropertyChanged"/> event.	/// </summary>    [TestFixture]	public class NotifyPropertyChangedEventTests : BasicServiceManagerTestFixtureBase	{		public static int s_Times1To2EventTriggered;		public static int s_Times2To1EventTriggered;		public NotifyPropertyChangedTestClass m_Peer1;
		public NotifyPropertyChangedTestClass m_Peer2;		/// <summary>		/// Gets around the problem of NUnit being crippled without testfixture setups.		/// </summary>        [SetUp]		public override void SetUp()		{			base.SetUp();			m_Peer1 = new NotifyPropertyChangedTestClass();			m_Peer2 = new NotifyPropertyChangedTestClass();			s_Times1To2EventTriggered = 0;			s_Times2To1EventTriggered = 0;		}

		/// <summary>		/// Need to unsubscribe and dispose.		/// </summary>        [TearDown]		public virtual void TearDown()		{			m_Peer1.Dispose();			m_Peer2.Dispose();		}		/// <summary>		/// This tests the ability to recognize when a property has NOT		/// changed value as well as proper firing of events in two directions.		/// </summary>		/// <remarks>		/// In this case, this test fixture is acting as an "intermediary" between		/// two peers that need to be connected. An intermediary of this type is		/// often referred to as a "binder", since it binds two objects together,		/// typically by hooking one or the other classes (or both) together		/// by registering handlers for receipt of notifications. 		/// </remarks>		[Test]		public void TwoWayTest()		{			// Peer 1 listens to peer 2.			m_Peer1.OneWayBindToMyPeer(m_Peer2);			// Peer 2 listens to peer 1.			m_Peer2.OneWayBindToMyPeer(m_Peer1);			// Set peer1's info twice, with the same data.			m_Peer1.AnAge = 81;			m_Peer1.AnAge = 81;			// Set peer1's info twice, with the same data.			m_Peer1.Aname = "name";			m_Peer1.Aname = "name";			// Set peer2's info twice, with the same data.			m_Peer2.AnAge = 34;			m_Peer2.AnAge = 34;			// Set peer2's info twice, with the same data.			m_Peer2.Aname = "anothername";			m_Peer2.Aname = "anothername";			// We did 4 attempts to set. 4 more will have been circulated			// back through the peer, but blocked due to no change in value.			Assert.IsTrue(m_Peer1.m_NumSetAttempts == 8, "8 attempts on peer1");			Assert.IsTrue(m_Peer2.m_NumSetAttempts == 8, "8 attempts on peer2");			// 4 attempts should have suceeded. 2 were the ones directly set			// on the class and two were circulated back with changed values.			Assert.IsTrue(m_Peer1.m_NumSetSuccesses == 4, "4 successes on peer1");			Assert.IsTrue(m_Peer2.m_NumSetSuccesses == 4, "4 successes on peer2");		}

		/// <summary>		/// This tests the ability to recognize when a property has NOT		/// changed value as well as proper firing of events in one direction.		/// Basically the same as <see cref="TwoWayTest"/> without registering		/// peer 2 to receive.		/// </summary>		/// <remarks>		/// In this case, this test fixture is acting as an "intermediary" between		/// two peers that need to be connected. An intermediary of this type is		/// often referred to as a "binder", since it binds two objects together,		/// typically by hooking one or the other classes (or both) together		/// by registering handlers for receipt of notifications. 		/// </remarks>        [Test]		public void OneWayTest()		{			// Peer 1 listens to peer 2.			m_Peer1.OneWayBindToMyPeer(m_Peer2);			// Peer 2 DOESN'T listen to peer 1.			// m_Peer2.OneWayBindToMyPeer(m_Peer1);			// Set peer1's info twice, with the same data.			m_Peer1.AnAge = 81;			m_Peer1.AnAge = 81;			// Set peer1's info twice, with the same data.			m_Peer1.Aname = "name";			m_Peer1.Aname = "name";			// Set peer2's info twice, with the same data.			m_Peer2.AnAge = 34;			m_Peer2.AnAge = 34;			// Set peer2's info twice, with the same data.			m_Peer2.Aname = "anothername";			m_Peer2.Aname = "anothername";

			// We did 4 attempts to set directly. 2 more were transmitted
			// from the peer. None were circulated through the unconnected peer.			Assert.IsTrue(m_Peer1.m_NumSetAttempts == 6, "6 attempts on peer1");
			// We did 4 attempts to set directly. None were transmitted from
			// the unconnected peer.			Assert.IsTrue(m_Peer2.m_NumSetAttempts == 4, "4 attempts on peer2");			// 4 attempts should have suceeded. 2 were the ones directly set			// on the class and two were circulated back with changed values.			Assert.IsTrue(m_Peer1.m_NumSetSuccesses == 4, "4 successes on peer1");			// 2 attempts should have suceeded. 2 were the ones directly set			// on the class and two were NOT circulated back from the unconnected node.			Assert.IsTrue(m_Peer2.m_NumSetSuccesses == 2, "2 successes on peer2");		}	}}