//@#$&+////The MIT X11 License////Copyright (c) 2018 Icucom Corporation////Permission is hereby granted, free of charge, to any person obtaining a copy//of this software and associated documentation files (the "Software"), to deal//in the Software without restriction, including without limitation the rights//to use, copy, modify, merge, publish, distribute, sublicense, and/or sell//copies of the Software, and to permit persons to whom the Software is//furnished to do so, subject to the following conditions:////The above copyright notice and this permission notice shall be included in//all copies or substantial portions of the Software.////THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,//FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN//THE SOFTWARE.//@#$&-using System.Collections.Generic;using Newtonsoft.Json;using Newtonsoft.Json.Serialization;using NUnit.Framework;using PlatformAgileFramework.Collections;
using PlatformAgileFramework.FileAndIO;using PlatformAgileFramework.FileAndIO.FileAndDirectoryService;using PlatformAgileFramework.FrameworkServices;using PlatformAgileFramework.FrameworkServices.Tests;// ReSharper disable once CheckNamespace
namespace PlatformAgileFramework.Logging.Tests{
	/// <summary>	/// These tests test the behavior of the JSON logger under non-concurrent	/// conditions. We test the JSON formatting and also the ability to close	/// the log file by adding terminating character before dispatch of a file.	/// The tests here show how to set up the rolling logger to simply dispatch	/// every file as it is written. We always cache the files locally due to	/// a specific client's requirements, but this is a general use case.	/// </summary>    [TestFixture]	public class JSONLoggerTests : BasicServiceManagerTestFixtureBase	{
		/// <summary>		/// Start dispatching files at this point.		/// </summary>        public static int s_MaxNumLogFiles = 1;		/// <summary>		/// Open new file at this point (never).		/// </summary>		public static int s_MaxFileSizeInBytes = int.MaxValue;		/// <summary>		/// Default is to check every time we write.		/// </summary>		public static int s_SizeCheckFrequency = 1;

		/// <summary>		/// Text to write. Writes the test DTO a couple of times.		/// </summary>		public static readonly string s_JSONFormattedText1;		public static readonly string s_JSONFormattedText2;
		/// <summary>		/// Name of the logger in the Service Manager.		/// </summary>        public static readonly string s_LoggerName;		/// <summary>		/// Logger file directory.		/// </summary>		public static string s_LoggerDirectory;		/// <summary>		/// "dispatch" file directory.		/// </summary>		public static string s_DispatchDirectory;		/// <summary>		/// For independently manipulating storage.		/// </summary>        public IPAFStorageService m_StorageService;		/// <summary>		/// Dispatcher for just moving files.		/// </summary>		public IPAFFormattingFileDispatcher m_FileMoveDispatcher;		/// <summary>		/// Dispatcher for Formatting and moving files. Handle for the		/// testing subclass.		/// </summary>		public AuditingTestFileDispatcher m_FileFormatAndMoveDispatcher;		/// <summary>		/// Need one copy of the service manager internals.		/// </summary>        internal IPAFServiceManagerInternal<IPAFService> m_ServiceManagerInternal;		/// <summary>		/// Builds our text.		/// </summary>        static JSONLoggerTests()		{			// weird linking problem requires this to be linked into main.			if (false)#pragma warning disable 162// ReSharper disable once HeuristicUnreachableCode				JsonConvert.SerializeObject(null);#pragma warning restore 162
			s_JSONFormattedText1				= PAFLoggingUtils.NewtonsoftFormatLog(new SimpleDTO { IntElement = 1, StringElement = "1" },					default(PAFLoggingLevel), null, null, false);			s_JSONFormattedText2				= PAFLoggingUtils.NewtonsoftFormatLog(new SimpleDTO { IntElement = 2, StringElement = "2" },					default(PAFLoggingLevel), null, null, false);			s_LoggerName = "JSONTestLogger";		}

		public override void TestFixtureSetUp()		{			base.TestFixtureSetUp();			m_ServiceManagerInternal				= (IPAFServiceManagerInternal<IPAFService>) PAFServices.Manager;			m_StorageService = PAFServices.Manager.GetTypedService<IPAFStorageService>();			s_LoggerDirectory =				"Documents:" + DS + "JSONTestLoggerDirectory";			s_DispatchDirectory =				"Documents:" + DS + "JSONTestDispatchDirectory";			m_FileMoveDispatcher				= new PAFFormattingFileDispatcher(s_DispatchDirectory);			// Always handle by the interface.			m_FileFormatAndMoveDispatcher				= new AuditingTestFileDispatcher(s_DispatchDirectory,					PAFLoggingUtils.JSONObjectListFormatForClose);		}		[SetUp]		public override void SetUp()		{			base.SetUp();			// Make sure the directory is there.			m_StorageService.PAFEnsureDirectoryExists(s_LoggerDirectory);			m_StorageService.PAFEnsureDirectoryExists(s_DispatchDirectory);			// Empty us out first.			m_StorageService.PAFEmptyDirectoryOfFiles(s_LoggerDirectory);			m_StorageService.PAFEmptyDirectoryOfFiles(s_DispatchDirectory);		}		/// <summary>		/// Writes ONE JSON-formatted log file, then checks the format.		/// </summary>		[Test]		public void CheckFormatOnFinishedJSONFile()		{			// Set up to check file size every time we write.			RollingLogger rollingLogger  =				new RollingLogger(					s_LoggerDirectory, "XXX.log",					s_MaxFileSizeInBytes,					s_MaxNumLogFiles, PAFLoggingUtils.NewtonsoftFormatLog,					s_SizeCheckFrequency, null, m_FileFormatAndMoveDispatcher.DispatchFiles);			var fileLogger = (IPAFLoggingService)rollingLogger;			var fileDispatcher = (IPAFFileDispatcher) rollingLogger;			// Always make the service fresh - core services are static.			var loggingServiceDescription				= new PAFServiceDescription<IPAFLoggingService>(fileLogger, s_LoggerName);			m_ServiceManagerInternal.AddOrReplaceServiceInternal(loggingServiceDescription);			// Grab the logger and log.			var logger = PAFServices.Manager.GetTypedService<IPAFLoggingService>(s_LoggerName);			logger.LogEntry(new SimpleDTO { IntElement = 1, StringElement = "1" });			// We need to write a second time to get enough to format.			logger.LogEntry(new SimpleDTO {IntElement = 2, StringElement = "2"});
			// Dispatch the files by formatting them and moving them.
			fileDispatcher.DispatchFilesIfNeeded();			// Figure out where they are being put. (Just one file).			var fileName = PAFFileUtils.SetOrReplaceDirectorySpecOnFiles(s_DispatchDirectory,				m_FileFormatAndMoveDispatcher.DispatchedFiles)[0];			var logFileContents				= ((IPAFLoggingServiceInternal)logger).ReadOutputFile(fileName);			//////////			// We do a couple of preliminary checks.			var foundBraces = logFileContents.Contains("}{");			Assert.IsTrue(!foundBraces, "Braces");			var foundFirstBracket = logFileContents[0] == '[';			var foundEndingBracket = logFileContents[logFileContents.Length - 1] == ']';			var bracketsCorrect = foundFirstBracket && foundEndingBracket;			Assert.IsTrue(bracketsCorrect, "Brackets");			// Now see if the deserialization works.			var deserializedObject = JsonConvert.DeserializeObject<IList<SimpleDTO>>(logFileContents);			var objectType = deserializedObject.GetType();			var typesConsistent = typeof(IList<SimpleDTO>).IsAssignableFrom(objectType);			Assert.IsTrue(typesConsistent, "Correct Json Type");			var theList =  deserializedObject;			var firstDTO = theList[0];			var firstInt = firstDTO.IntElement;			Assert.IsTrue(firstInt == 1, "FirstInt");		}	}}